#!/usr/bin/perl

# Search syntax documented in a conflicting manner here:
#
#  http://www.rpcurnow.force9.co.uk/mairix/mairix.html#command_005fline
#
#  foo s:bar/baz=2,~qux,moo=
#  ( ) (                   )  AND <- space-delimited
#        (                 ) applies to subject only
#        ( ) (             )  OR  <- slash-delimited
#            (   ) (  ) (  )  AND <- comma-delimited
#  i.e.
#    foo AND s:(bar OR ((baz, 2 errors)  AND (NOT qux) AND (SUBSTRING moo)))

use strict;
use warnings;

$SIG{PIPE} = sub {
  warn "got SIGPIPE\n";
  sleep 2;
};

use File::Path;
use File::Which;

use Mairix;

my %fields = map { $_ => 1 } qw(Subject From To);

sub usage {
  die <<EOF;
Usage:
  $0 prompter
  $0 field Subject < mail
EOF
}

usage() unless @ARGV;
my $mode = shift @ARGV;

unless ($ENV{MAIRIX_RESULTS}) {
  die "\$MAIRIX_RESULTS not set; aborting.\n";
}

if ($ENV{MAIRIX_RESULTS} =~ /mairix/i &&
    -d "$ENV{MAIRIX_RESULTS}/cur"     &&
    -d "$ENV{MAIRIX_RESULTS}/new"     &&
    -d "$ENV{MAIRIX_RESULTS}/tmp")
{
  # We do this so that an abandoned or failed run of mairix won't
  # result in mutt still switching to an irrelevant results folder.
  # mairix will automatically recreate the results folder on success.
  rmtree($ENV{MAIRIX_RESULTS});
}

my $mairix = which('mairix');
die "Can't find executable mairix!\n" unless $mairix;

if ($mode eq 'prompt') {
  print "mairix query? ";
  chomp(my $query = <STDIN>);
  if ($query) {
    my @words = split /\s+/, $query;
    my $exit_code = do_query(@words);
    # mutt's wait_key mechanism will ask for a key press on failure
    exit $exit_code;
  }
}
elsif ($mode eq 'field') {
  usage() unless @ARGV;
  my $field = shift @ARGV;
  die "$0: Can't follow unsupported field '$field'\n"
    unless $fields{$field};

  my $value = '';
  while (<STDIN>) {
    chomp;

    last if /^$/; # no longer in header
    
    if (! $value) {
      if (/^$field:\s+(.+)/) {
        $value = $1;
      }
      next;
    }

    if (/^\s+(.+)/) {
      # continuation of header
      $value .= " " . $1;
      next;
    }

    # continuation ended
    last;
  }

  die "$0: Didn't find '$field' field in header\n" unless $value;

  my @query = get_query($field, $value);
  my $exit_code = do_query(@query);
  # mutt's wait_key mechanism will ask for a key press on failure
  exit $exit_code;
}
else {
  die "$0: Invalid mode '$mode'\n";
}

sub get_query {
  my ($field, $value) = @_;

  if ($field eq 'From') {
    # extract email address and real name
    # search for real name (AND of all words) OR email address
    require Mail::Address;
    die "TODO";
  }

  if ($field eq 'Subject') {
    return Mairix::subject_query($value);
  }

  die "BUG";
}

sub do_query {
  my (@query) = @_;
  warn "Searching for: @query\n";
  my $query_file = "$ENV{HOME}/.mairix/last-query";
  open(QUERY, ">$query_file")
    or die "Couldn't open($query_file): $!\n";
  print QUERY "@query\n";
  close(QUERY);
  system($mairix, @query);
  return $? >> 7;
}
